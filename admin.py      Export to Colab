from flask import Blueprint, request, jsonify
from firebase_admin import firestore, auth
import logging
from datetime import datetime, timedelta
import pytz
import numpy as np

db = firestore.client()
logger = logging.getLogger(__name__)

admin_bp = Blueprint('admin_bp', __name__, url_prefix='/admin')

# This helper will be connected from the main app
def verify_admin_token_wrapper(token):
    return False, None 

@admin_bp.before_request
def before_request_func():
    token = request.headers.get("Authorization", "").split("Bearer ")[-1]
    is_admin, _ = verify_admin_token_wrapper(token)
    if not is_admin:
        return jsonify({'message': 'Unauthorized'}), 403

# All routes from here will automatically be protected by the check above

@admin_bp.route('/users', methods=['GET'])
def get_all_users():
    try:
        users = db.collection("users").stream()
        return jsonify([doc.to_dict() | {"uid": doc.id} for doc in users]), 200
    except Exception as e:
        logger.error(f"Get all users failed: {e}", exc_info=True)
        return jsonify({'message': str(e)}), 500

@admin_bp.route('/update-user', methods=['POST'])
def update_user_status():
    try:
        content = request.get_json(force=True)
        uid, new_status, new_role, new_hospital = content.get("uid"), content.get("status"), content.get("role"), content.get("hospital")
        if not uid: return jsonify({'message': 'UID is required'}), 400
        
        updates = {}
        if new_status in ["active", "pending", "rejected"]: updates["status"] = new_status
        if new_role in ["Medical physicist", "RSO", "Admin"]: updates["role"] = new_role
        if new_hospital and new_hospital.strip():
             updates["hospital"] = new_hospital
             updates["centerId"] = new_hospital

        if not updates: return jsonify({'message': 'No valid fields for update'}), 400

        db.collection("users").document(uid).update(updates)
        # Simplified for brevity - add audit logging and email notifications back if needed
        return jsonify({'status': 'success'}), 200
    except Exception as e:
        logger.error(f"Update user failed: {e}", exc_info=True)
        return jsonify({'message': str(e)}), 500

@admin_bp.route('/delete-user', methods=['DELETE'])
def delete_user():
    try:
        uid_to_delete = request.get_json(force=True).get("uid")
        if not uid_to_delete: return jsonify({'message': 'Missing UID'}), 400
        
        try:
            auth.delete_user(uid_to_delete)
        except Exception as auth_e:
            if "User record not found" not in str(auth_e): raise auth_e

        db.collection("users").document(uid_to_delete).delete()
        # Add audit logging back if needed
        return jsonify({'status': 'success'}), 200
    except Exception as e:
        logger.error(f"Delete user failed: {e}", exc_info=True)
        return jsonify({'message': str(e)}), 500

@admin_bp.route('/audit-logs', methods=['GET'])
def get_audit_logs():
    try:
        query = db.collection("audit_logs").order_by("timestamp", direction=firestore.Query.DESCENDING)
        
        # Add filters for hospital, action, date if needed
        
        logs = [doc.to_dict() for doc in query.limit(200).stream()]
        # Process timestamps and user details as before
        for log in logs:
            if 'timestamp' in log:
                 log['timestamp'] = log['timestamp'].astimezone(pytz.timezone('Asia/Kolkata')).strftime('%Y-%m-%d %H:%M:%S')

        return jsonify({"logs": logs}), 200
    except Exception as e:
        logger.error(f"Get audit logs failed: {e}", exc_info=True)
        return jsonify({'message': str(e)}), 500
